package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:
    boolean errorDetected = false;
    Logger log = Logger.getLogger(getClass());

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
        done_parsing();
        report_error(message, info);
    }

    public void syntax_error(Symbol curr_token) {
        report_error("\nSintaksna greska", curr_token);
    }

    public void unrecovered_syntax_error(Symbol curr_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", curr_token);
    }

    public void report_error(String message, Object info) {
        errorDetected = true;
        StringBuilder msg = new StringBuilder(message);
        if (info instanceof Symbol) {
            msg.append(" na liniji ").append(((Symbol)info).left);
        }
        log.error(msg.toString());
    }
:}

scan with {:
    Symbol s = this.getScanner().next_token();
    if (s != null && s.value != null) {
        log.info(s.toString() + " " + s.value.toString());
    }
    return s;
:}

terminal PROGRAM, ENUM, CLASS, ABSTRACT, CONST, VOID, EXTENDS;
terminal BREAK, ELSE, IF, NEW, PRINT, READ, RETURN, CONTINUE, FOR, LENGTH, SWITCH, CASE;
terminal PLUS, MINUS, MUL, DIV, MOD, AND, OR, ASSIGN, INC, DEC;
terminal EQUAL, NOT_EQUAL, GREATER, GREATER_EQUAL, LESS, LESS_EQUAL;
terminal SEMI, COLON, COMMA, DOT, LPAREN, RPAREN, LBRACKET, RBRACKET, LBRACE, RBRACE, QUESTION;
terminal String IDENT;
terminal Integer NUM_CONST;
terminal Character CHAR_CONST;
terminal Boolean BOOL_CONST;

nonterminal Program, DeclarationList;
nonterminal ConstDeclaration, VarDeclaration, ClassDeclaration, EnumDeclaration, AbstractClassDeclaration;
nonterminal Type, ConstList, Const, VarList, Var, EnumConstList, EnumConst;
nonterminal MethodDeclarationList, AbstractClassMethodDeclarationList, VarDeclarationList;
nonterminal MethodDeclaration, AbstractMethodDeclaration, MethodHeader, FormalParamsList, FormalParam;
nonterminal StatementList, Statement, DesignatorStatement, Designator, CaseList, Case;
nonterminal IfDeclaration, ReturnDeclaration, PrintDeclaration, ForDeclaration;
nonterminal Expression, Condition, ActualParamsList, SuffixList, Suffix, ConditionFact, ConditionTerm;
nonterminal Term, TermList, Factor, FactorList, Sign, ArithmeticExpression;
nonterminal ProgramName, EnumName, ClassName, AbstractClassName, ArrayName, MethodName, AbstractMethodName;

precedence left ELSE;

Program ::= (Program) PROGRAM ProgramName DeclarationList LBRACE MethodDeclarationList RBRACE;
ProgramName ::= (ProgramName) IDENT;
DeclarationList ::= (DeclarationListConst) DeclarationList ConstDeclaration
                    |
                    (DeclarationListVar) DeclarationList VarDeclaration
                    |
                    (DeclarationListClass) DeclarationList ClassDeclaration
                    |
                    (DeclarationListEnum) DeclarationList EnumDeclaration
                    |
                    (DeclarationListAbstractClass) DeclarationList AbstractClassDeclaration
                    |
                    (DeclarationListEmpty) /* epsilon */
                    ;
ConstDeclaration ::= (ConstDeclaration) CONST Type ConstList SEMI;
Type ::= (Type) IDENT;
ConstList ::= (ConstListMultiple) ConstList COMMA Const
              |
              (ConstListSingle) Const
              ;
Const ::= (ConstNum) IDENT ASSIGN NUM_CONST
          |
          (ConstChar) IDENT ASSIGN CHAR_CONST
          |
          (ConstBool) IDENT ASSIGN BOOL_CONST
          ;
VarDeclaration ::= (VarDeclaration) Type VarList SEMI;
VarList ::= (VarListMultiple) VarList COMMA Var
            |
            (VarListSingle) Var
            ;
Var ::= (VarSingle) IDENT
        |
        (VarArray) ArrayName LBRACKET RBRACKET
        ;
ArrayName ::= (ArrayName) IDENT;
EnumDeclaration ::= (EnumDeclaration) ENUM EnumName LBRACE EnumConstList RBRACE;
EnumName ::= (EnumName) IDENT;
EnumConstList ::= (EnumConstListMultiple) EnumConstList COMMA EnumConst
                  |
                  (EnumConstListSingle) EnumConst
                  ;
EnumConst ::= (EnumConstNoAssign) IDENT
              |
              (EnumConstAssign) IDENT ASSIGN NUM_CONST
              ;
ClassDeclaration ::= (ClassDeclarationExtends) CLASS ClassName EXTENDS Type LBRACE VarDeclarationList LBRACE MethodDeclarationList RBRACE RBRACE
                     |
                     (ClassDeclarationNoExtends) CLASS ClassName LBRACE VarDeclarationList LBRACE MethodDeclarationList RBRACE RBRACE
                     ;
ClassName ::= (ClassName) IDENT;
VarDeclarationList ::= (VarDeclarationListMore) VarDeclarationList VarDeclaration
                       |
                       (VarDeclarationListEmpty) /* epsilon */
                       ;
MethodDeclarationList ::= (MethodDeclarationListMore) MethodDeclarationList MethodDeclaration
                          |
                          (MethodDeclarationListEmpty) /* epsilon */
                          ;
MethodDeclaration ::= (MethodDeclaration) MethodHeader VarDeclarationList LBRACE StatementList RBRACE;
MethodHeader ::= (MethodHeaderType) Type MethodName LPAREN FormalParamsList RPAREN
                 |
                 (MethodHeaderNoParams) Type MethodName LPAREN RPAREN
                 |
                 (MethodHeaderVoid) VOID MethodName LPAREN FormalParamsList RPAREN
                 |
                 (MethodHeaderVoidNoParams) VOID MethodName LPAREN RPAREN
                 ;
MethodName ::= (MethodName) IDENT;
AbstractClassDeclaration ::= (AbstractClassDeclarationExtends) ABSTRACT CLASS AbstractClassName EXTENDS Type LBRACE AbstractClassMethodDeclarationList RBRACE
                             |
                             (AbstractClassDeclarationNoExtends) ABSTRACT CLASS AbstractClassName LBRACE AbstractClassMethodDeclarationList RBRACE
                             ;
AbstractClassName ::= (AbstractClassName) IDENT;
AbstractClassMethodDeclarationList ::= (AbstractClassMethodDeclarationListAbstract) AbstractClassMethodDeclarationList AbstractMethodDeclaration
                                       |
                                       (AbstractClassMethodDeclarationListConcrete) AbstractClassMethodDeclarationList MethodDeclaration
                                       |
                                       (AbstractClassMethodDeclarationListEmpty) /* epsilon */
                                       ;
AbstractMethodDeclaration ::= (AbstractMethodDeclaration) ABSTRACT MethodHeader SEMI;
FormalParamsList ::= (FormalParamsListMultiple) FormalParamsList COMMA FormalParam
                     |
                     (FormalParamsListSingle) FormalParam
                     ;
FormalParam ::= (FormalParam) Type Var;
StatementList ::= (StatementListMore) StatementList Statement
                  |
                  (StatementListEmpty) /* epsilon */
                  ;
Statement ::= (StatementDesignator) DesignatorStatement SEMI
              |
              (StatementIf) IfDeclaration
              |
              (StatementBreak) BREAK SEMI
              |
              (StatementContinue) CONTINUE SEMI
              |
              (StatementReturn) ReturnDeclaration
              |
              (StatementRead) READ LPAREN Designator RPAREN SEMI
              |
              (StatementPrint) PrintDeclaration
              |
              (StatementSwitch) SWITCH LPAREN Expression RPAREN LBRACE CaseList RBRACE
              |
              (StatementFor) ForDeclaration
              |
              (StatementBlock) LBRACE StatementList RBRACE
              ;
IfDeclaration ::= (IfDeclarationElse) IF LPAREN Condition RPAREN Statement ELSE Statement
                  |
                  (IfDeclarationNoElse) IF LPAREN Condition RPAREN Statement
                  ;
ReturnDeclaration ::= (ReturnDeclarationExpression) RETURN Expression SEMI
                      |
                      (ReturnDeclarationNoExpression) RETURN SEMI
                      ;
PrintDeclaration ::= (PrintDeclarationNumConst) PRINT LPAREN Expression COMMA NUM_CONST RPAREN SEMI
                     |
                     (PrintDeclarationNoNumConst) PRINT LPAREN Expression RPAREN SEMI
                     ;
ForDeclaration ::= (ForDeclarationFull) FOR LPAREN DesignatorStatement SEMI Condition SEMI DesignatorStatement RPAREN Statement
                   |
                   (ForDeclarationNoInit) FOR LPAREN SEMI Condition SEMI DesignatorStatement RPAREN Statement
                   |
                   (ForDeclarationNoCond) FOR LPAREN DesignatorStatement SEMI SEMI DesignatorStatement RPAREN Statement
                   |
                   (ForDeclarationNoAct) FOR LPAREN DesignatorStatement SEMI Condition SEMI RPAREN Statement
                   |
                   (ForDeclarationNoInitNoCond) FOR LPAREN SEMI SEMI DesignatorStatement RPAREN Statement
                   |
                   (ForDeclarationNoInitNoAct) FOR LPAREN SEMI Condition SEMI RPAREN Statement
                   |
                   (ForDeclarationNoCondNoAct) FOR LPAREN DesignatorStatement SEMI SEMI RPAREN Statement
                   |
                   (ForDeclarationNoInitNoCondNoAct) FOR LPAREN SEMI SEMI RPAREN Statement
                   ;
CaseList ::= (CaseListMore) CaseList Case
             |
             (CaseListEmpty) /* epsilon */
             ;
Case ::= (Case) CASE NUM_CONST COLON StatementList;
DesignatorStatement ::= (DesignatorStatementAssign) Designator ASSIGN Expression
                        |
                        (DesignatorStatementFunctionCall) Designator LPAREN ActualParamsList RPAREN
                        |
                        (DesignatorStatementFunctionCallNoParams) Designator LPAREN RPAREN
                        |
                        (DesignatorStatementIncrement) Designator INC
                        |
                        (DesignatorStatementDecrement) Designator DEC
                        ;
ActualParamsList ::= (ActualParamsListMultiple) ActualParamsList COMMA Expression
                     |
                     (ActualParamsListSingle) Expression
                     ;
Designator ::= (DesignatorSuffixList) IDENT SuffixList
               |
               (DesignatorNoSuffixList) IDENT
               ;
SuffixList ::= (SuffixListMultiple) SuffixList Suffix
               |
               (SuffixListSingle) Suffix
               ;
Suffix ::= (SuffixField) DOT IDENT
           |
           (SuffixLength) DOT LENGTH
           |
           (SuffixIndex) LBRACKET Expression RBRACKET
           ;
Expression ::= (ExpressionArithmetic) ArithmeticExpression
               |
               (ExpressionTernary) Condition QUESTION Expression COLON Expression
               ;
ArithmeticExpression ::= (ArithmeticExpression) Term TermList;
TermList ::= (TermListPlus) TermList PLUS Term
             |
             (TermListMinus) TermList MINUS Term
             |
             (TermListEmpty) /* epsilon */
             ;
Term ::= (Term) Factor FactorList;
FactorList ::= (FactorListTimes) FactorList MUL Factor
               |
               (FactorListDivide) FactorList DIV Factor
               |
               (FactorListModulo) FactorList MOD Factor
               |
               (FactorListEmpty) /* epsilon */
               ;
Factor ::= (FactorVariable) Sign Designator
           |
           (FactorFunctionCallWithArgs) Sign Designator LPAREN ActualParamsList RPAREN
           |
           (FactorFunctionCallNoArgs) Sign Designator LPAREN RPAREN
           |
           (FactorNumConst) Sign NUM_CONST
           |
           (FactorBoolConst) BOOL_CONST
           |
           (FactorCharConst) CHAR_CONST
           |
           (FactorNewArray) NEW Type LBRACKET Expression RBRACKET
           |
           (FactorNested) LPAREN Expression RPAREN
           ;
Sign ::= (SignMinus) MINUS
         |
         (SignEmpty) /* epsilon */
         ;
Condition ::= (ConditionMultiple) Condition OR ConditionTerm
              |
              (ConditionSingle) ConditionTerm
              ;
ConditionTerm ::= (ConditionTermMultiple) ConditionTerm AND ConditionFact
                  |
                  (ConditionTermSingle) ConditionFact
                  ;
ConditionFact ::= (ConditionFactNoRelOp) ArithmeticExpression
                  |
                  (ConditionFactEqual) ArithmeticExpression EQUAL ArithmeticExpression
                  |
                  (ConditionFactNotEqual) ArithmeticExpression NOT_EQUAL ArithmeticExpression
                  |
                  (ConditionFactGreater) ArithmeticExpression GREATER ArithmeticExpression
                  |
                  (ConditionFactGreaterEqual) ArithmeticExpression GREATER_EQUAL ArithmeticExpression
                  |
                  (ConditionFactLess) ArithmeticExpression LESS ArithmeticExpression
                  |
                  (ConditionFactLessEqual) ArithmeticExpression LESS_EQUAL ArithmeticExpression
                  ;
